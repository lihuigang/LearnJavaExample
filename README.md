# LearnJavaExample

1.排序算法
冒泡排序:
    1.第一次排序将最大的数到队尾
    2.第二次排序将第二大的数放到倒数第二位
插入排序:
    1.分为已排序部分和未排序部分
    2.取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入
选择排序:
    1.分为已排序部分和未排序部分
    2.每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾

归并排序
    1.

    递推公式：
        merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))
    终止条件：
        p >= r 不用再继续分解

快速排序

    递推公式：
        quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)

    终止条件：
        p >= r
堆排序
    应用场景:
        多个有序小文件合并为一个有序大文件

2.树结构

    满二叉树
        定义:除了叶子节点之外，每个节点都有左右两个子节点

    完全二叉树
        定义:叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。
    红黑树
        定义:
            1)根节点是黑色的；
            2)每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
            3)任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
            4)每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；
        概念:左旋，右旋

        应用:

    递归树
        定义:递归一层一层的分解过程画成图，它其实就是一棵树
        应用:
            1)分析快速排序的时间复杂度
            2)分析斐波那契数列的时间复杂度
            3)分析全排列的时间复杂度

    堆
        定义:一层一层的分解过程画成图，它其实就是一棵树
        堆的应用:
           1) 中位数
           2) topN
           3) 99%

    赫夫曼树
        定义:n个带权值作为n个叶子节点，带权路径长度达到最小的二叉树，叫赫夫曼树

3.字符串匹配